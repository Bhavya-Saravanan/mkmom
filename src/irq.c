/***********************************************************************
 * @file      irq.c
 * @version   1.0
 * @brief     Source file for IRQ (Interrupt Request) handling and processing.
 *
 * @author    Bhavya Saravanan, bhsa3618@colorado.edu
 * @date      23-02-2025
 *
 * @institution University of Colorado Boulder (UCB)
 * @course      ECEN 5823: IoT Embedded Firmware
 * @instructor  Chris Choi
 *
 * @resources  Lecture slides
 *
 ***********************************************************************/

#include "irq.h"
#include "em_letimer.h"
#include "gpio.h"
#include "em_core.h"
#include "scheduler.h"
#include <stdint.h>
#include "src/log.h"

#include "scheduler.h"
#include "em_gpio.h"
#include "em_core.h"
#include "ble.h"

volatile uint32_t milliseconds = 0;

/**
 * @brief Retrieves the current system time in milliseconds.
 *
 * This function returns the number of milliseconds since the program started.
 *
 * @param None
 * @return uint32_t - Current time in milliseconds.
 */
uint32_t letimerMilliseconds()
{
    return milliseconds;  // Return the global counter
}

/**
 * @brief LETIMER0 Interrupt Handler.
 *
 * This function handles UF (Underflow) and COMP1 (Compare Match) interrupts
 * generated by the LETIMER0 peripheral. It clears interrupt flags and schedules
 * corresponding events.
 *
 * @param None
 * @return None
 */
void LETIMER0_IRQHandler(void)
{
    CORE_DECLARE_IRQ_STATE;
    CORE_ENTER_CRITICAL();

    uint32_t intFlags = LETIMER_IntGetEnabled(LETIMER0);  // Get active interrupt flags
    LETIMER_IntClear(LETIMER0, intFlags);

    if (intFlags & LETIMER_IF_UF) {
        schedulerSetEventUF();  // Notify scheduler of underflow event
        milliseconds += 3000;  // Increment system time by 3 seconds
    }

    if (intFlags & LETIMER_IF_COMP1) {

        schedulerSetEventCOMP1();  // Notify scheduler that delay expired
        LETIMER_IntDisable(LETIMER0, LETIMER_IF_COMP1);
    }

    CORE_EXIT_CRITICAL();  // Exit critical section
}

/**
 * @brief Handles GPIO even-numbered interrupts (including PB0 button press).
 *
 * This interrupt service routine (ISR) is triggered when an even-numbered GPIO pin
 * generates an interrupt. It reads the interrupt flags, clears them, and checks if
 * the PB0 button was pressed or released. Based on the button state, it schedules
 * the appropriate event.
 *
 * @param None
 * @return None
 */

void GPIO_EVEN_IRQHandler(void)
{
    CORE_DECLARE_IRQ_STATE;
    CORE_ENTER_CRITICAL();

    uint32_t flags = GPIO_IntGet();
    GPIO_IntClear(flags);//clearing the interrupts

    if (flags & (1 << PB0_PIN)) {
        bool pressed = (GPIO_PinInGet(PB0_PORT, PB0_PIN) == 0);  // 0 when pressed
        if ( pressed)
            schedulerSetEventPB0Pressed();
        else
            schedulerSetEventPB0Released();

    }

    CORE_EXIT_CRITICAL();
}
/**
 * @brief Handles GPIO odd-numbered interrupts (including PB1 button press).
 *
 * This interrupt service routine (ISR) is triggered when an even-numbered GPIO pin
 * generates an interrupt. It reads the interrupt flags, clears them, and checks if
 * the PB1 button was pressed or released. Based on the button state, it schedules
 * the appropriate event.
 *
 * @param None
 * @return None
 */
void GPIO_ODD_IRQHandler(void) {
    CORE_DECLARE_IRQ_STATE;
    CORE_ENTER_CRITICAL();

    uint32_t flags = GPIO_IntGet();
    GPIO_IntClear(flags);

    if (flags & (1 << PB1_PIN)) {
        bool pressed = (GPIO_PinInGet(PB1_PORT, PB1_PIN) == 0);  // Active Low
        if (pressed) {
            schedulerSetEventPB1Pressed();
        } else {
            schedulerSetEventPB1Released();
        }
    }

    CORE_EXIT_CRITICAL();
}
